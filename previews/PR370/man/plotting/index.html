<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting · SolidStateDetectors.jl</title><meta name="title" content="Plotting · SolidStateDetectors.jl"/><meta property="og:title" content="Plotting · SolidStateDetectors.jl"/><meta property="twitter:title" content="Plotting · SolidStateDetectors.jl"/><meta name="description" content="Documentation for SolidStateDetectors.jl."/><meta property="og:description" content="Documentation for SolidStateDetectors.jl."/><meta property="twitter:description" content="Documentation for SolidStateDetectors.jl."/><meta property="og:url" content="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/man/plotting/"/><meta property="twitter:url" content="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/man/plotting/"/><link rel="canonical" href="https://JuliaPhysics.github.io/SolidStateDetectors.jl/stable/man/plotting/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="SolidStateDetectors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SolidStateDetectors.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../config_files/">Configuration Files</a></li><li><a class="tocitem" href="../csg/">Constructive Solid Geometry (CSG)</a></li><li><a class="tocitem" href="../Grids/">Grids</a></li><li><a class="tocitem" href="../electric_potential/">Electric Potential</a></li><li><a class="tocitem" href="../electric_field/">Electric Field</a></li><li><a class="tocitem" href="../charge_drift/">Charge Drift</a></li><li><a class="tocitem" href="../weighting_potentials/">Weighting Potentials</a></li><li><a class="tocitem" href="../capacitances/">Capacitances</a></li><li><a class="tocitem" href="../IO/">IO</a></li><li class="is-active"><a class="tocitem" href>Plotting</a><ul class="internal"><li><a class="tocitem" href="#Detector-Plots"><span>Detector Plots</span></a></li><li><a class="tocitem" href="#Scalar-Potential-Plots"><span>Scalar Potential Plots</span></a></li><li><a class="tocitem" href="#Electric-Field-Plots"><span>Electric Field Plots</span></a></li><li><a class="tocitem" href="#Event-Plots"><span>Event Plots</span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/complete_simulation_chain_IVC/">Simulation Chain: Inverted Coax Detector</a></li><li><a class="tocitem" href="../../tutorials/custom_impurity_density_pn_junction/">Advanced Example: Custom Impurity Profile</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Plotting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhysics/SolidStateDetectors.jl/blob/main/docs/src/man/plotting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h1><p>In order to plot geometries or simulation results, the user will need to load the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> package.</p><p>First, we have to calculate something in order to demonstrate the plotting tools:</p><pre><code class="language-julia hljs">using Plots
using SolidStateDetectors
using Unitful

T = Float32
sim = Simulation{T}(SSD_examples[:InvertedCoax]);
simulate!(sim, convergence_limit = 1e-6, refinement_limits = [0.2, 0.1, 0.05, 0.01]);</code></pre><p>Besides the usual <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> keywords settings, like <code>size = (500, 500)</code>, there are some additional settings to tune the plots which are described in the following sections.</p><h2 id="Detector-Plots"><a class="docs-heading-anchor" href="#Detector-Plots">Detector Plots</a><a id="Detector-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Detector-Plots" title="Permalink"></a></h2><p>The geometry of a detector, together with its environment, can be simply plotted via</p><pre><code class="language-julia hljs">det = sim.detector
plot(det, size = (500, 500))</code></pre><img src="8a4f01bd.svg" alt="Example block output"/><h3 id="Plot-Styles"><a class="docs-heading-anchor" href="#Plot-Styles">Plot Styles</a><a id="Plot-Styles-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Styles" title="Permalink"></a></h3><p>The style of the detector plot can be controlled via the <code>seriestype</code> keyword. There are 4 available styles:</p><pre><code class="language-julia hljs">plot(
      plot(det, seriestype = :csg, title = &quot;:csg&quot;),
      plot(det, seriestype = :wireframe, title = &quot;:wireframe&quot;),
      plot(det, seriestype = :mesh3d, title = &quot;:mesh3d&quot;),
      plot(
            det, seriestype = :samplesurface, n_samples = 100,
            markersize = 2, markeralpha = 0.03, title = &quot;:samplesurface&quot;
            ),
      layout = (1,4), size = (800,200), legend = false, ticks = false,
      guide = &quot;&quot;, zlims = (-0.005,0.1)
)</code></pre><img src="1eebba73.svg" alt="Example block output"/><p>The <code>seriestype</code> can be set to <code>:csg</code> (default), <code>:wireframe</code>, <code>:mesh3d</code>, or <code>:samplesurface</code>. <code>:csg</code> plots a wireframe on top of a mesh (with no mesh gridlines). For fastest plotting use either <code>:wireframe</code> or <code>:mesh3d</code> and consider changing <code>n_arc</code> (see <a href="#Optional-Keywords">Optional Keywords</a>). <code>:csg</code>, <code>:wireframe</code>, and <code>:mesh3d</code> are all mesh-based. For geometries containing differences or intersections the recommended seriestype is <code>:samplesurface</code>. This can be seen by plotting the detector&#39;s semiconductor below. <code>:samplesurface</code> is marker-based. The marker density is set low by default for speed. For increased plot fidelity use <code>n_samples = 100</code> and <code>markersize = 2</code>.</p><pre><code class="language-julia hljs">plot(
      plot(det.semiconductor, seriestype = :csg, title = &quot;:csg&quot;),
      plot(det.semiconductor, seriestype = :wireframe, title = &quot;:wireframe&quot;),
      plot(det.semiconductor, seriestype = :mesh3d, title = &quot;:mesh3d&quot;),
      plot(
            det.semiconductor, seriestype = :samplesurface, n_samples = 100,
            markersize = 2, markeralpha = 0.03, title = &quot;:samplesurface&quot;
            ),
      layout = (1,4), size = (800,200), legend = false, ticks = false,
      guide = &quot;&quot;, zlims = (-0.005,0.1)
)</code></pre><img src="94ad4aae.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>So far, when using mesh-based seriestypes (<code>:csg</code>, <code>:wireframe</code>, <code>:mesh3d</code>), plots are produced by plotting whole primitives. Thus, usually, nicer plots are produced if the geometry consists only of unions of primitives and not differences or intersections. If the geometry contains differences, the resulting negative geometries are plotted with thinner wireframe lines and/or with semi-transparent white mesh faces depending on the <code>seriestype</code> used. </p></div></div><h3 id="How-does-the-plot-recipe-work?"><a class="docs-heading-anchor" href="#How-does-the-plot-recipe-work?">How does the plot recipe work?</a><a id="How-does-the-plot-recipe-work?-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-the-plot-recipe-work?" title="Permalink"></a></h3><p>The detector consists of a semiconductor, <code>det.semiconductor</code>, its contacts, <code>det.contacts</code>, and its surrounding objects, <code>det.passives</code>. By default (see <a href="#Optional-Keywords">Optional Keywords</a>), only the contacts and the surrounding objects are plotted and the color of the contact primitives is defined internally through their <code>id</code>.</p><p>Components can also be plotted individually for enhanced style handling. Additionally, the units of the axes are set by calling a <code>plot</code> command with units beforehand.</p><pre><code class="language-julia hljs">plot(u&quot;cm&quot;, u&quot;cm&quot;, u&quot;cm&quot;)
plot!(det.semiconductor, st = :samplesurface, n_samples = 100, markersize = 2,
      camera = (40, 55), size = (500, 500))
plot!(det.contacts[1], st = :mesh3d, linewidth = 0.5, fillcolor = :white)
plot!(det.contacts[2], st = :wireframe, n_vert_lines = 5)</code></pre><img src="e5753176.svg" alt="Example block output"/><h3 id="Optional-Keywords"><a class="docs-heading-anchor" href="#Optional-Keywords">Optional Keywords</a><a id="Optional-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-Keywords" title="Permalink"></a></h3><ul><li><code>show_semiconductor</code>: Will display the semiconductor if set to <code>true</code>. Default is <code>false</code>.</li><li><code>show_passives</code>: Will display the objects surrounding the detector if set to <code>true</code>. Default is <code>true</code>.</li><li><code>seriestype</code>: Can be <code>:csg</code> (default), <code>:wireframe</code>, <code>:mesh3d</code>, or <code>:samplesurface</code>.</li><li><code>linewidth</code>: Sets the line width of the edges of the mesh gridlines when using <code>seriestype = :mesh3d</code>. When using <code>seriestype = :csg</code> or <code>seriestype = :wireframe</code>, <code>linewidth</code> sets the line width of the wireframe.</li><li><code>linecolor</code>: Sets the line color of the edges of the mesh gridlines when using <code>seriestype = :mesh3d</code>. When using <code>seriestype = :csg</code> or <code>seriestype = :wireframe</code>, <code>linecolor</code> sets the line color of the wireframe.</li><li><code>fillcolor</code>: Sets the face color of all faces of the mesh.</li><li><code>fillalpha</code>: Sets the alpha value of all faces of the mesh.</li><li><code>markercolor</code>: Sets the marker color.</li><li><code>markersize</code>: Sets the marker size. <code>markersize = 4</code> is the default value.</li><li><code>markeralpha</code>: Sets the alpha value for markers.</li><li><code>n_arc</code>: Controls the discretization of curved objects in a mesh. Each full ellipse is divided into <code>n_arc</code> segments. Partial ellipses are drawn with a proportional number (<code>n_arc*f</code> with <code>f&lt;1</code>) of segments.<code>n_arc = 40</code> is the default value. Smaller <code>n_arc</code> values will result in faster plotting, specially if the geometry contains tori or ellipsoids.</li><li><code>n_vert_lines</code>: Controls the number of wireframe &quot;vertical&quot; lines in a mesh. <code>n_vert_lines = 2</code> is the default value. A maximum of <code>n_arc*f</code> vertical lines can be drawn on each curved object. This keyword is ignored by polygons.</li><li><code>n_samples</code>: Controls the marker density. <code>n_samples = 40</code> is the default value. Reduce this value for faster plotting. Consider increasing <code>markersize</code> and/or <code>markeralpha</code> to compensate for the visual impact of lower marker densities. Note that the marker density is intended to be even across all dimensions. Therefore, visual distortions will occur if the aspect ratio of the axes is far from unity.</li></ul><h2 id="Scalar-Potential-Plots"><a class="docs-heading-anchor" href="#Scalar-Potential-Plots">Scalar Potential Plots</a><a id="Scalar-Potential-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Potential-Plots" title="Permalink"></a></h2><p>When calculating the electric potential, a set of scalar potentials are stored in the <code>Simulation</code> object, e.g. <code>sim.electric_potential</code>, <code>sim.point_types</code>, and <code>sim.q_eff_imp</code>. SolidStateDetectors.jl has plot recipes for these scalar potentials.</p><pre><code class="language-julia hljs">plot(sim.electric_potential)</code></pre><img src="eb0daf4f.svg" alt="Example block output"/><p>There are several keyword arguments that can be passed to adjust the potential plots. First, the simulated potentials are simulated on a three-dimensional <code>Grid</code>, but the plots will always be a two-dimensional cross section (for a <code>CylindricalGrid</code> at constant <code>r</code>, <code>φ</code> or <code>z</code>, for a <code>CartesianGrid3D</code> at constant <code>x</code>, <code>y</code> or <code>z</code>). The cross section can be specified in the <code>plot</code> command. A cross section of the <code>ElectricPotential</code> at <code>z = 20mm</code> can be plotted via</p><pre><code class="language-julia hljs">plot(sim.electric_potential, z = 20u&quot;mm&quot;)</code></pre><img src="aa8a54a7.svg" alt="Example block output"/><p>In addition to all plot attributes that are implemented in <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, plots of scalar potentials can take two additional keyword arguments, <code>contours_equal_potential</code> and <code>full_det</code>, which both are of type <code>Bool</code>:</p><ul><li><code>contours_equal_potential</code>: If this set to <code>true</code>, the plot will additionally display contour lines at points with equal potential value.</li><li><code>full_det</code>: By default, cross sections in <code>φ</code> are only displayed for positive radii <code>r</code>. If <code>full_det</code> is set to <code>true</code>, cross sections in <code>φ</code> are also extended to &quot;negative&quot; <code>r</code>, by additionally plotting the potential values at <code>φ + 180°</code> on the left side of the plot.</li></ul><pre><code class="language-julia hljs">plot( sim.electric_potential, φ = 30u&quot;°&quot;,
      contours_equal_potential = true, full_det = true,
      linecolor = :white, levels = 34)</code></pre><img src="4185581f.svg" alt="Example block output"/><h2 id="Electric-Field-Plots"><a class="docs-heading-anchor" href="#Electric-Field-Plots">Electric Field Plots</a><a id="Electric-Field-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-Field-Plots" title="Permalink"></a></h2><p>The magnitude of the electric field can be plotted using the same syntax as <a href="#Scalar-Potential-Plots">Scalar Potential Plots</a>.</p><pre><code class="language-julia hljs">plot(sim.electric_field, full_det = true, clims = (0, 5e5))</code></pre><img src="bad27984.svg" alt="Example block output"/><p>In addition, SolidStateDetectors.jl offers the possibilities to plot electric field lines via <code>plot_electric_fieldlines</code>. This is done by spawning charges close to the surface of the contacts and simulating their drift parallel to the electric field, using <a href="../../api/#SolidStateDetectors.ElectricFieldChargeDriftModel"><code>ElectricFieldChargeDriftModel</code></a>.</p><pre><code class="language-julia hljs">plot_electric_fieldlines!(sim, full_det = true)</code></pre><img src="47bdbe98.svg" alt="Example block output"/><p>In addition to all plot attributes that are implemented in <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>, the syntax for specifying the cross section and <code>full_det</code> (see <a href="#Scalar-Potential-Plots">Scalar Potential Plots</a>), the plot recipe for electric field lines can additionally understand the following arguments to tune the plot.</p><ul><li><code>sampling</code>: Specifies the steps at which the contacts are sampled to generate equally spaced charges at the surface. The default is <code>2u&quot;mm&quot;</code>, but the optimal value depends on the geometry of the detector and contacts. If no unit is given, <code>sampling</code> is interpreted in units of meter.</li><li><code>offset</code>: The charges are created on the surface and have to be moved slightly inside the semiconductor to be able to drift (charges that are in the contacts will not drift). This keyword defines how much the charges will be moved inside along the normal vector of the surface. The default is <code>0.5u&quot;mm&quot;</code>, but the optimal value again depends on the detector geometry. Unitless quantities are interpreted in units of meter.</li><li><code>skip_contact</code>: Detectors will usually have positively and negatively biased contacts. The charges should only be spawned on either of them, but not both. This keyword defines which contact should be skipped in the charge spawn algorithm. Default is <code>1</code>, i.e. that no charges will be spawned at the surface of contact with <code>id = 1</code>.</li><li><code>max_nsteps</code>: After all, the generation of electric field lines is based on the charge drift code, which requires a maximum number of steps, which is set to <code>5000</code> by default here. If the drift ends before the charges reach a contact, the electric field line will not be fully displayed. In this case, it is recommended to increase <code>max_nsteps</code>.</li></ul><p>In case the electric field line plots do not look good, adjust <code>sampling</code>, <code>offset</code> and <code>max_nsteps</code> until obtaining the desired result.</p><pre><code class="language-julia hljs">plot(sim.electric_field, full_det = true, size = (500,500), clims = (0,5e5))
plot_electric_fieldlines!(sim, full_det = true, sampling = 3u&quot;mm&quot;, offset = 2u&quot;mm&quot;)</code></pre><img src="11f07f0c.svg" alt="Example block output"/><h2 id="Event-Plots"><a class="docs-heading-anchor" href="#Event-Plots">Event Plots</a><a id="Event-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Event-Plots" title="Permalink"></a></h2><p>SolidStateDetectors.jl also provides plot recipes to display charge drift paths resulting from simultaneous energy deposits in the semiconductor body of the detector. To simulate and plot an individual event, the <code>Event</code> struct is recommended.</p><pre><code class="language-julia hljs">evt = Event([CartesianPoint{T}(0.01,0.01,0.075)], [2u&quot;MeV&quot;])
simulate!(evt, sim)
plot(sim.detector, size = (500,500), label = &quot;&quot;)
plot!(evt.drift_paths)</code></pre><img src="9d1879c0.svg" alt="Example block output"/><p>The drift path plots can be modified using the keywords implemented in <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. The units of the axes can be set by calling a <code>plot</code> command with units beforehand:</p><pre><code class="language-julia hljs">plot(u&quot;mm&quot;, u&quot;mm&quot;, u&quot;mm&quot;)
plot!(sim.detector, size = (500,500), label = &quot;&quot;)
plot!(evt.drift_paths, linewidth = 2, linestyle = :dash, markersize = 6)</code></pre><img src="f27b5845.svg" alt="Example block output"/><p>There are also plot recipes for plotting the simulated waveforms of the <code>Event</code>:</p><pre><code class="language-julia hljs">plot(evt.waveforms, unitformat = :slash, label = &quot;Contact &quot;.*string.((1:2)&#39;), legend = :topleft)</code></pre><img src="f87644f6.svg" alt="Example block output"/><p>The length of the waveforms is given by the length of the charge drift. By default, no baseline and no tail are added to the waveforms. However, this might be desired in waveforms plots. The waveforms can be extended by calling <a href="../../api/#SolidStateDetectors.add_baseline_and_extend_tail-Union{Tuple{UV}, Tuple{TV}, Tuple{U}, Tuple{T}, Tuple{RadiationDetectorSignals.RDWaveform{T, U, TV, UV}, Int64, Int64}} where {T, U, TV, UV}"><code>add_baseline_and_extend_tail</code></a> on the waveforms. Again, the units of the axes can be set by calling a <code>plot</code> command with units before plotting the waveforms.</p><pre><code class="language-julia hljs">plot(u&quot;µs&quot;, u&quot;fC&quot;)
plot!(add_baseline_and_extend_tail.(evt.waveforms,0,400),
      linewidth = 4, linestyle = :dash,
      label = &quot;&quot;, unitformat = :slash)</code></pre><img src="091406d2.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../IO/">« IO</a><a class="docs-footer-nextpage" href="../../tutorials/complete_simulation_chain_IVC/">Simulation Chain: Inverted Coax Detector »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 26 March 2024 19:47">Tuesday 26 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
